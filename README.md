



#### 8.2 整数拆分

```C++
f(n,k)=1					//n=0 || k=0
f(n,k)=f(n,n)				//m==k
f(n,k)=f(n,k-1)+1			//n < k
f(n,k)=f(n-k,k)+f(n,k-1)	// 其他情况
```

#### 8.3 最大连续子序列和

```C++
dp[0]=0		//边界条件
dp[j]=MAX{dp[j-1]+a[j], a[j]}	//1<=j<=n
```

#### 8.4 三角形最小路径

```C++
dp[0][0]=a[0][0]		//顶部边界
dp[i][0]=dp[i-1][0]+a[i][0]	//第1列的边界
dp[i][i]=dp[i-1][i-1]+a[i][i]	//对角线的边界
dp[i][j]=min(dp[i-1][j-1], dp[i-1][j]) +a[i][j]
```

#### 8.5 最长公共子序列

```C++
dp[i][j]=0								//i=0 || j=0
dp[i][j]=dp[i-1][j-1]+1					//a[i-1]=b[j-1]
dp[i][j]=MAX(dp[i][j-1], dp[i-1][j])	//a[i-1]!=b[j-1]
```

#### 8.6 最长递增子序列

```C++
dp[i]=1						
dp[i]=max(dp[i], dp[j+1])		//a[i]>a[j]
```

#### 8.7 编辑距离

```C++
dp[i][j]=dp[i-1][j-1]			//当a[i-1]=b[j-1]
dp[i][j]=min(dp[i-1][j-1]+1, dp[i][j-1]+1, dp[i-1][j]+1)		//当a[i-1]!=b[j-1]
```

#### 8.8 0/1背包

```C++
dp[i][0]=0			//背包不能装入任何物品
dp[0][r]=0			//没有任何物品可装入
dp[i][r]=dp[i-1][r]	//r<w[i], 装不下
dp[i][r]=max(dp[i-1][r], dp[i-1][r-w[i]]+v[i])	//否则在放和不放之间选最优解
```

#### 8.9 完全背包

```C++
dp[i][j]=MAX{dp[i-1][j-k*w[i]]+k*v[i]}		//当dp[i][j] < dp[i-1][j-k*w[i]]+k*v[i]时
fk[i][j]=k
```

#### 8.10 资源分配

```C++
dp[m+1][j]=0	//边界条件
dp[i][s]=max(v[i][j]+dp[i+1][s-j])
```

